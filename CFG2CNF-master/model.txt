Terminals:
+ - ( ) ^ number variable
Variables:
Expr Term AddOp MulOp Factor Primary
Productions:
Expr -> Term;
Expr -> Expr AddOp Term;
Expr -> AddOp Term;
Term -> Factor;
Term -> Term MulOp Factor;
Factor -> Primary;
Factor -> Factor ^ Primary;
Primary -> number;
Primary -> variable;
Primary -> ( Expr );
AddOp -> +;
AddOp -> -;
MulOp -> *;
MulOp -> /;

simple_stmt -> expression_stmt;
simple_stmt -> assert_stmt;
simple_stmt -> assignment_stmt;
simple_stmt -> augmented_assignment_stmt;
simple_stmt -> annotated_assignment_stmt;
simple_stmt -> pass_stmt;
simple_stmt -> del_stmt;
simple_stmt -> return_stmt;
simple_stmt -> raise_stmt;
simple_stmt -> break_stmt;
simple_stmt -> continue_stmt;
simple_stmt -> import_stmt;
simple_stmt -> future_stmt;
simple_stmt -> global_stmt;
simple_stmt -> nonlocal_stmt;
expression_stmt -> starred_expression;
assignment_stmt -> (target_list "=")+ (starred_expression);
target_list -> target ("," target)* [","];
target -> identifier;
target -> "(" [target_list] ")";
target -> "[" [target_list] "]";
target -> attributeref;
target -> subscription;
target -> slicing;
target -> "*" target;
augmented_assignment_stmt -> augtarget augop (expression_list);
augtarget -> identifier;
augtarget -> attributeref;
augtarget -> subscription;
augtarget -> slicing;
augop -> "+=";
augop -> "-=";
augop -> "*=";
augop -> "@=";
augop -> "/=";
augop -> "//=";
augop -> "%=";
augop -> "**=";
augop -> ">>=";
augop -> "<<=";
augop -> "&=";
augop -> "^=";
augop -> "|=";
annotated_assignment_stmt -> augtarget ":" expression '<newline>' ["=" (starred_expression)];
assert_stmt -> "assert" expression ["," expression];
pass_stmt -> "pass";
del_stmt -> "del" target_list;
return_stmt -> "return" [expression_list];
raise_stmt -> "raise" [expression ["from" expression]];
break_stmt -> "break";
continue_stmt -> "continue";
import_stmt -> "import" module ["as" identifier] ("," module ["as" identifier])*;
import_stmt -> "from" relative_module "import" identifier ["as" identifier] '<newline>' ("," identifier ["as" identifier])*;
import_stmt -> "from" relative_module "import" "(" identifier ["as" identifier] '<newline>' ("," identifier ["as" identifier])* [","] ")";
import_stmt -> "from" module "import" "*";
module -> (identifier ".")* identifier;
relative_module -> "."* module | "."+;
future_stmt -> "from" "__future__" "import" feature ["as" identifier] '<newline>' ("," feature ["as" identifier])*;
future_stmt -> "from" "__future__" "import" "(" feature ["as" identifier] '<newline>' ("," feature ["as" identifier])* [","] ")";
feature -> identifier;
global_stmt -> "global" identifier ("," identifier)*;
nonlocal_stmt -> "nonlocal" identifier ("," identifier)*;

compound_stmt -> if_stmt;
compound_stmt -> while_stmt;
compound_stmt -> for_stmt;
compound_stmt -> try_stmt;
compound_stmt -> with_stmt;
compound_stmt -> funcdef;
compound_stmt -> classdef;
suite -> stmt_list NEWLINE;
suite -> NEWLINE INDENT statement+ DETENT;
statement -> stmt_list NEWLINE;
statement -> compound_stmt;
stmt_list -> simple_stmt Za Zb;
Za -> e;
Za -> ";" simple_stmt;
Za -> Za ";" simple_stmt;
Zb -> e;
Zb -> ";"

if_stmt -> "if" Expr ":" suite '<newline>' A '<newline>' Z;
A -> e;
A -> "elif" Expr ":" suite;
A -> A "elif" Expr ":" suite;
Z -> e;
Z -> "else" ":" suite;

while_stmt -> "while" Expr ":" suite '<newline>' Z;
for_stmt -> "for" target_list "in" expression_list ":" suite '<newline>' Z;
with_stmt -> "with" with_item F ":" suite;
F -> e;
F -> "," with_item;
F -> F "," with_item;

with_item -> Expr B;
B -> e;
B -> "as" target;

funcdef -> C "def" funcname "(" D ")" '<newline>' E ":" suite;
C -> decorators;
C -> e;
D -> parameter_list;
D -> e;
E -> "->" Expr;
E -> e;
decorators -> decorator+;
decorator -> "@" dotted_name G '<newline>';
G -> e;
G -> "(" H ")";
H -> e;
H -> argument_list I;
I -> e;
I -> ",";
dotted_name -> identifier J;
J -> e;
J -> "." identifier;
J -> J "." identifier;
parameter_list -> defparameter K "," "/" L;
K -> e;
K -> "," defparameter;
K -> K "," defparameter;
L -> e;
L -> "," M;
M -> e;
M -> parameter_list_no_posonly;
parameter_list -> parameter_list_no_posonly;
parameter_list_no_posonly -> defparameter N O;
N -> e;
N -> "," defparameter;
N -> N "," defparameter;
O -> e;
O -> "," P;
P -> e;
P -> parameter_list_starargs;
parameter_list_no_posonly -> parameter_list_starargs;
parameter_list_starargs -> "*" Q N R;
Q -> e;
Q -> parameter;
R -> e;
R -> "," S;
S -> e;
S -> "**" parameter I;
parameter_list_starargs -> "**" parameter I;
parameter -> identifier T;
T -> e;
T -> ":" Expr;
defparameter -> parameter U;
U -> e;
U -> "=" Expr;
funcname -> identifier;
classdef -> V "class" classname W ":" suite;
V -> e;
V -> decorators;
W -> e;
W -> inheritance;
inheritance -> "(" X ")";
X -> e;
X -> argument_list;
classname -> identifier;


or_test -> and_test Y;
Y -> e;
Y -> 'or' and_test;
Y -> Y 'or' and_test;
and_test-> not_test vara;
vara -> e;
vara -> 'and' not_test;
vara -> vara 'and' not_test;
not_test -> 'not' not_test;
not_test -> comparison;
comparison -> Expr varb;
varb -> e;
varb -> comp_op Expr;
varb -> varb comp_op Expr;
comp_op -> '<';
comp_op -> '>';
comp_op -> '==';
comp_op -> '>=';
comp_op -> '<=';
comp_op -> '<>';
comp_op -> '!=';
comp_op -> 'in';
comp_op -> 'not' 'in';
comp_op -> 'is';
comp_op -> 'is' 'not';

false_stmt -> "False";
none -> "None";
true -> "True";

identifier -> xid_start xid_continue*;
id_start -> <all characters in general categories Lu, Ll, Lt, Lm, Lo, Nl, the underscore, and characters with the Other_ID_Start property>;
id_continue -> <all characters in id_start, plus characters in the categories Mn, Mc, Nd, Pc and others with the Other_ID_Continue property>;
xid_start -> <all characters in id_start whose NFKC normalization is in "id_start xid_continue*">;
xid_continue -> <all characters in id_continue whose NFKC normalization is in "id_continue*">